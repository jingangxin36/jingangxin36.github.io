<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="LEEYOUNG 在 Github 上的个人博客">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="Jingangxin36" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        完全二叉树的应用 - 图解堆排序算法及代码实现｜LEEYOUNG&#39;s blog
        
    </title>

    <link rel="canonical" href="https://jingangxin36.github.io/2018/05/20/完全二叉树的应用 - 图解堆排序算法及代码实现/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('//o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Jingangxin36
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="">


<style>
    
    header.intro-header {
        background-image: url('')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>完全二叉树的应用 - 图解堆排序算法及代码实现</h1>
                    
                    <span class="meta">
                         作者 LEEYOUNG
                        <span>
                          日期 2018-05-20
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            完全二叉树的应用 - 图解堆排序算法及代码实现
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="1-二叉堆"><a href="#1-二叉堆" class="headerlink" title="1. 二叉堆"></a>1. 二叉堆</h1><p>堆是一个数组A, 它可以被看成一个近似的完全二叉树<br><img src="https://img-blog.csdn.net/20180414220025145?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdhbmd4aW42NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>以(a)二叉树和(b)数组形式展现的是一个最大堆. 结点上方的数字是它在数组中相应的下标.</p>
<p>若一个结点下标为$i$, 可以得到它的父结点, 左孩子和右孩子的下标:</p>
<ul>
<li>PARENT($i$)<ul>
<li><strong>return </strong>  $i / 2$</li>
</ul>
</li>
<li>LEFT($i$):<ul>
<li><strong>return </strong>  $2i$</li>
</ul>
</li>
<li>RIGHT($i$):<ul>
<li><strong>return </strong>  $2i + 1$</li>
</ul>
</li>
</ul>
<p><strong>更加快速地计算?</strong></p>
<ul>
<li>在大多数计算机中,<code>LEFT</code>过程可以在<strong>一条指令内</strong>(左移1位)计算出$2i$, <code>RIGHT</code>过程可以通过将$i$左移1位并低位加1, <strong>快速计算</strong>出$2i+1$. <code>RIGHT</code>过程可以通过把$i$的值右移1位计算得到$i/2$. 在堆排序的好的实现中, 这三个函数通常是以<code>宏(define)</code>或<code>内联函数(inline)</code>实现的. </li>
</ul>
<p><strong>注意: 根节点的下标不是0而是1</strong></p>
<ul>
<li>所以, 代码中的所有Index都需要考虑减去1, 满足数组的初始下标为0的规律</li>
</ul>
<h1 id="2-重要步骤"><a href="#2-重要步骤" class="headerlink" title="2. 重要步骤"></a>2. 重要步骤</h1><ul>
<li><strong>MaxHeapify</strong>: 负责维护最大堆, 时间复杂度为$O($lg$n)$</li>
<li><strong>BuildMaxHeap</strong>: 负责从一个无序的输入数据数组中构造最大堆, 时间复杂度为$O(n)$</li>
<li><strong>HeapSort</strong>: 负责对一个数组进行原址排序, 时间复杂度为$O(n$lg$n)$</li>
</ul>
<h1 id="3-维护堆的性质"><a href="#3-维护堆的性质" class="headerlink" title="3. 维护堆的性质"></a>3. 维护堆的性质</h1><p><code>MaxHeapify(A, i)</code>是用于维护最大堆性质的重要过程. 在调用该函数时, 我们假定根结点为LEFT($i$)和RIGHT($i$)的二叉树都是最大堆. 如果A[$i$]小于其孩子, 则违背了最大堆的性质. <code>MaxHeapify(A, i)</code>通过让A[$i$]的值在最大堆中”逐级下降”, 从而使下标为$i$的跟结点的子树重新遵循最大堆的性质.</p>
<p><strong>下图展示了<code>MaxHeapify</code>的过程</strong><br><img src="https://img-blog.csdn.net/20180414220101331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdhbmd4aW42NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>代码实现为:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 负责维护最大堆</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">private void MaxHeapify(int[] originInts, int rootIndex, int heapSize) &#123;            </span><br><span class="line">    if ((rootIndex &lt;&lt; 1) + 1 &gt; heapSize) return;</span><br><span class="line">    //如果当前结点不是叶子结点</span><br><span class="line">    var maxClildIndex = FindMaxClildIndex(originInts, rootIndex, heapSize);</span><br><span class="line">    //如果根结点满足大顶堆条件, 结束维护大顶堆过程</span><br><span class="line">    if (maxClildIndex == rootIndex) return;</span><br><span class="line">    //如果根结点小于子结点</span><br><span class="line">    Swap(ref originInts[maxClildIndex], ref originInts[rootIndex]);</span><br><span class="line">    //发生替换, 需要检查新的子结点是否满足大顶堆条件</span><br><span class="line">    MaxHeapify(originInts, maxClildIndex, heapSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思考</strong></p>
<p>递归调用可能使某些编译器产生低效的代码, 可以用循环控制结构取代递归, 用伪代码重写为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAX-HEAPIFY(A, i)</span><br><span class="line">    while true</span><br><span class="line">        left = LEFT(i)</span><br><span class="line">        right = RIGHT(i)</span><br><span class="line">        if left &gt; A.heap-size</span><br><span class="line">	        return</span><br><span class="line">        largest = FIND-MAX-CHILD-INDEX(A, i)</span><br><span class="line">        if largest == i</span><br><span class="line">            return</span><br><span class="line">        exchange A[i] with A[largest]</span><br><span class="line">        i = largest</span><br></pre></td></tr></table></figure>
<h1 id="4-建堆"><a href="#4-建堆" class="headerlink" title="4. 建堆"></a>4. 建堆</h1><p>我们可以用自底向上的方法利用<code>BuildMaxHeap</code>把一个大小n = A.Length 的数组A[1..n]转换为最大堆. 每一个叶结点都可以看成只包含一个元素的堆(此时无需建立子堆). 过程<code>BuildMaxHeap</code>对树中的其它结点(非叶子结点)都调用一次<code>MaxHeapify</code>.</p>
<p>我们利用<code>heapSize</code>来表示每一次构成大顶堆时的总结点数(即堆的大小),  堆初始化时, <code>heapSize = A.Length</code></p>
<p><strong>下图展示了<code>BuildMaxHeap</code>的过程</strong></p>
<p><img src="https://img-blog.csdn.net/20180414220114393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdhbmd4aW42NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>代码实现为:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 负责从一个无序的输入数据数组中构造最大堆</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">private void BuildMaxHeap(int[] originInts, int heapSize) &#123;</span><br><span class="line">    //获得最后一个结点的父结点 -&gt; 需要维护的起始结点</span><br><span class="line">    var currentIndex = (heapSize - 1) &gt;&gt; 1;</span><br><span class="line">    //自底向上建立大顶堆</span><br><span class="line">    while (currentIndex &gt;= 0) &#123;</span><br><span class="line">        MaxHeapify(originInts, currentIndex--, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-堆排序算法"><a href="#5-堆排序算法" class="headerlink" title="5. 堆排序算法"></a>5. 堆排序算法</h1><p>初始时, 堆排序算法利用<code>BuildMaxHeap</code>将输入的数组A[1..n]建成最大堆. 其中n = A.Length. 因为数组中的最大元素总是在A[1]中, 通过把它与A[n]进行替换, 可以把该元素放到正确的位置. 此时, 需要从堆中去掉该结点(可以通过设置<code>heapSize -= 1</code>来实现), 再将剩下的结点构造成大顶堆(通过调用<code>MaxHeapify(A, 1)</code>)</p>
<p><strong>下图展示了<code>堆排序算法</code>的过程</strong></p>
<p><img src="https://img-blog.csdn.net/20180414220127261?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdhbmd4aW42NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180414220135771?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdhbmd4aW42NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>代码实现为:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 负责对一个数组进行原址排序</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public int[] HeapSort(int[] originInts) &#123;</span><br><span class="line">    if (originInts == null || originInts.Length == 0) &#123;</span><br><span class="line">        return originInts;</span><br><span class="line">    &#125;</span><br><span class="line">    //需要排序的堆结点数</span><br><span class="line">    var heapSize = originInts.Length;</span><br><span class="line">    PrintArray(&quot;初始数组&quot;, originInts);</span><br><span class="line">    //构造大顶堆	</span><br><span class="line">    BuildMaxHeap(originInts, heapSize);</span><br><span class="line">    var count = 1;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        PrintArray(&quot;第&quot; + count++ + &quot;个大顶堆&quot;, originInts);                </span><br><span class="line">        //取出最大的结点放到数组尾部&gt;&gt;Swap(A[1], A[heapSize])</span><br><span class="line">        Swap(ref originInts[0], ref originInts[heapSize-- -1]);</span><br><span class="line">        //如果此时只剩下一个结点, 排序结束</span><br><span class="line">        if (heapSize == 1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        //维护A[1]大顶堆, 直至heapSize == 1</span><br><span class="line">        MaxHeapify(originInts,0, heapSize);               </span><br><span class="line">    &#125;</span><br><span class="line">    PrintArray(&quot;排序后数组&quot;, originInts);            </span><br><span class="line">    return originInts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 查看是否满足大顶堆条件</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;returns&gt;返回一个最大的孩子索引或者父结点&lt;/returns&gt;</span><br><span class="line">private int FindMaxClildIndex(int[] originInts, int rootIndex, int heapSize) &#123;</span><br><span class="line">    var leftChildIndex = (rootIndex &lt;&lt; 1) + 1;</span><br><span class="line">    //排除已经排序好的子结点</span><br><span class="line">    if (leftChildIndex &gt; heapSize - 1) &#123;</span><br><span class="line">        return rootIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    var rightChildIndex = (rootIndex &lt;&lt; 1) + 2;</span><br><span class="line">    var maxIndex = leftChildIndex;</span><br><span class="line">    //如果有右孩子, 比较左孩子和右孩子</span><br><span class="line">    if (rightChildIndex &lt;= heapSize - 1) &#123;</span><br><span class="line">        if (originInts[rightChildIndex] &gt; originInts[leftChildIndex]) &#123;</span><br><span class="line">            maxIndex = rightChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //比较根结点和最大的孩子</span><br><span class="line">    if (originInts[rootIndex] &gt; originInts[maxIndex]) &#123;</span><br><span class="line">        maxIndex = rootIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 负责打印数组</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">private void PrintArray(string info, int[] originInts) &#123;</span><br><span class="line">    Console.Write(info + &quot;: &quot;);</span><br><span class="line">    foreach (var temp in originInts) &#123;</span><br><span class="line">        Console.Write(temp + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 负责交换两个数字</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">private void Swap(ref int a, ref int b) &#123;</span><br><span class="line">    var temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>输入: { 3, 27, 4, 5, 6, 8 , 13, 46}</code></p>
<p><strong>运行结果为:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始数组: 3 27 4 5 6 8 13 46</span><br><span class="line">第1个大顶堆: 46 27 13 5 6 8 4 3</span><br><span class="line">第2个大顶堆: 27 6 13 5 3 8 4 46</span><br><span class="line">第3个大顶堆: 13 6 8 5 3 4 27 46</span><br><span class="line">第4个大顶堆: 8 6 4 5 3 13 27 46</span><br><span class="line">第5个大顶堆: 6 5 4 3 8 13 27 46</span><br><span class="line">第6个大顶堆: 5 3 4 6 8 13 27 46</span><br><span class="line">第7个大顶堆: 4 3 5 6 8 13 27 46</span><br><span class="line">排序后数组: 3 4 5 6 8 13 27 46</span><br></pre></td></tr></table></figure></p>
<h1 id="6-堆排序的应用"><a href="#6-堆排序的应用" class="headerlink" title="6. 堆排序的应用"></a>6. 堆排序的应用</h1><ul>
<li><a href="https://blog.csdn.net/jingangxin666/article/details/79958896" target="_blank" rel="noopener"> 如何基于最大堆实现最大优先队列</a></li>
</ul>
<p>#7. 参考</p>
<ul>
<li><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">算法导论（原书第3版）</a></li>
</ul>

                <hr>
                

                <ul class="pager">
                    
                    
                    <li class="next">
                        <a href="/2018/05/20/图解HTTP-1-了解Web及网络基础/" data-toggle="tooltip" data-placement="top"
                           title="图解HTTP-1-了解Web及网络基础">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                
            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-二叉堆"><span class="toc-text">1. 二叉堆</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-重要步骤"><span class="toc-text">2. 重要步骤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-维护堆的性质"><span class="toc-text">3. 维护堆的性质</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-建堆"><span class="toc-text">4. 建堆</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-堆排序算法"><span class="toc-text">5. 堆排序算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-堆排序的应用"><span class="toc-text">6. 堆排序的应用</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/ehazon">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/megahertz">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/haojen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/haojen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Jingangxin36 2018
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://jingangxin36.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="">
</body>

</html>
